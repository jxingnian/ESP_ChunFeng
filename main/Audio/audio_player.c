/*
 * @Author: generated by assistant
 * @Description: 简易音频播放器实现
 */
#include "audio_player.h"
#include "audio_hal.h"
#include "lottie_manager.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"
#include "esp_heap_caps.h"
#include <string.h>
#include <stdlib.h>

typedef struct {
    uint8_t *buffer;
    size_t   size;
    volatile size_t write_pos;
    volatile size_t read_pos;
    SemaphoreHandle_t mutex;
    SemaphoreHandle_t data_sem;
} pcm_ring_t;

static const char *TAG = "AUDIO_PLAYER";
static pcm_ring_t s_rb = {0};
static TaskHandle_t s_task = NULL;
static size_t s_frame_samples = 1024;
static bool s_running = false;
static bool s_speak_anim_active = false;

static esp_err_t rb_init(pcm_ring_t *rb, size_t bytes)
{
    if (!rb || bytes == 0) return ESP_ERR_INVALID_ARG;

    // 优先使用PSRAM分配大缓冲区
    rb->buffer = (uint8_t *)heap_caps_malloc(bytes, MALLOC_CAP_SPIRAM);
    if (!rb->buffer) {
        ESP_LOGW(TAG, "PSRAM分配失败，尝试内部RAM");
        rb->buffer = (uint8_t *)malloc(bytes);
    }

    if (!rb->buffer) {
        ESP_LOGE(TAG, "缓冲区分配失败，需要%d字节", (int)bytes);
        return ESP_ERR_NO_MEM;
    }

    // 检查分配的内存类型
    if (heap_caps_get_allocated_size(rb->buffer) > 0) {
        bool is_psram = heap_caps_check_integrity(MALLOC_CAP_SPIRAM, true);
        ESP_LOGI(TAG, "音频缓冲区分配成功: %d KB, 位置: %s",
                 (int)(bytes / 1024),
                 (esp_ptr_external_ram(rb->buffer)) ? "PSRAM" : "内部RAM");
    }

    rb->size = bytes;
    rb->write_pos = rb->read_pos = 0;
    rb->mutex = xSemaphoreCreateMutex();
    rb->data_sem = xSemaphoreCreateBinary();
    if (!rb->mutex || !rb->data_sem) return ESP_ERR_NO_MEM;
    return ESP_OK;
}

static void rb_deinit(pcm_ring_t *rb)
{
    if (!rb) return;
    if (rb->mutex) vSemaphoreDelete(rb->mutex);
    if (rb->data_sem) vSemaphoreDelete(rb->data_sem);
    if (rb->buffer) free(rb->buffer);
    memset(rb, 0, sizeof(*rb));
}

static size_t rb_write(pcm_ring_t *rb, const uint8_t *data, size_t len)
{
    if (!rb || !data || len == 0) return 0;
    if (xSemaphoreTake(rb->mutex, pdMS_TO_TICKS(10)) != pdTRUE) return 0;
    size_t space = (rb->read_pos <= rb->write_pos)
                   ? (rb->size - rb->write_pos + rb->read_pos - 1)
                   : (rb->read_pos - rb->write_pos - 1);
    if (len > space) len = space;
    for (size_t i = 0; i < len; ++i) {
        rb->buffer[rb->write_pos] = data[i];
        rb->write_pos = (rb->write_pos + 1) % rb->size;
    }
    xSemaphoreGive(rb->mutex);
    if (len) xSemaphoreGive(rb->data_sem);
    return len;
}

static size_t rb_read(pcm_ring_t *rb, uint8_t *out, size_t max_len, uint32_t timeout_ms)
{
    if (!rb || !out || max_len == 0) return 0;
    if (rb->read_pos == rb->write_pos && timeout_ms) {
        if (xSemaphoreTake(rb->data_sem, pdMS_TO_TICKS(timeout_ms)) != pdTRUE) return 0;
    }
    if (xSemaphoreTake(rb->mutex, pdMS_TO_TICKS(10)) != pdTRUE) return 0;
    size_t avail = (rb->write_pos >= rb->read_pos)
                   ? (rb->write_pos - rb->read_pos)
                   : (rb->size - rb->read_pos + rb->write_pos);
    if (max_len > avail) max_len = avail;
    for (size_t i = 0; i < max_len; ++i) {
        out[i] = rb->buffer[rb->read_pos];
        rb->read_pos = (rb->read_pos + 1) % rb->size;
    }
    xSemaphoreGive(rb->mutex);
    return max_len;
}

static void player_task(void *arg)
{
    const size_t bytes_per_sample = sizeof(int16_t);
    const size_t frame_bytes = s_frame_samples * bytes_per_sample;
    int16_t *frame = (int16_t *)malloc(frame_bytes);
    if (!frame) {
        s_running = false;
        vTaskDelete(NULL);
        return;
    }
    
    int no_data_count = 0;
    const int max_no_data_count = 5; // 200ms * 25 = 5秒无数据后停止动画
    
    while (s_running) {
        size_t got = rb_read(&s_rb, (uint8_t *)frame, frame_bytes, 200);
        if (got >= bytes_per_sample) {
            size_t samples = got / bytes_per_sample;
            audio_hal_write(frame, samples, 100);
            
            // 有音频数据，启动speak动画
            if (!s_speak_anim_active) {
                s_speak_anim_active = true;
                ESP_LOGI(TAG, "开始播放speak动画");
                lottie_manager_play_anim_at_pos(LOTTIE_ANIM_SPEAK,0,-100);
                // lottie_manager_play_anim(LOTTIE_ANIM_THINK);
            }
            no_data_count = 0;
        } else {
            // 没有音频数据
            no_data_count++;
            if (s_speak_anim_active && no_data_count >= max_no_data_count) {
                s_speak_anim_active = false;
                ESP_LOGI(TAG, "停止speak动画");
                lottie_manager_stop_anim(LOTTIE_ANIM_SPEAK);
                lottie_manager_play_anim_at_pos(LOTTIE_ANIM_THINK,0,-50);
                no_data_count = 0;
            }
        }
    }
    
    // 任务结束时停止动画
    if (s_speak_anim_active) {
        s_speak_anim_active = false;
        ESP_LOGI(TAG, "播放器停止，停止speak动画");
        lottie_manager_stop_anim(LOTTIE_ANIM_SPEAK);
    }
    
    free(frame);
    vTaskDelete(NULL);
}

esp_err_t audio_player_init(size_t ring_bytes, size_t frame_samples)
{
    if (s_running) return ESP_ERR_INVALID_STATE;
    if (ring_bytes == 0) ring_bytes = 64 * 1024;
    if (frame_samples == 0) frame_samples = 1024;
    ESP_ERROR_CHECK(audio_hal_init());
    s_frame_samples = frame_samples;
    audio_hal_set_volume(10);
    return rb_init(&s_rb, ring_bytes);
}

void audio_player_deinit(void)
{
    if (s_running) return;
    rb_deinit(&s_rb);
}

// 音频播放任务栈 - 放在PSRAM
#define AUDIO_PLAYER_STACK_SIZE (3 * 1024 / sizeof(StackType_t))
static EXT_RAM_BSS_ATTR StackType_t audio_player_stack[AUDIO_PLAYER_STACK_SIZE];
static StaticTask_t audio_player_task_buffer;

esp_err_t audio_player_start(void)
{
    if (s_running) return ESP_ERR_INVALID_STATE;
    s_running = true;
    
    // 使用静态任务创建，栈在PSRAM
    s_task = xTaskCreateStatic(
        player_task,                // 任务函数
        "audio_player",             // 任务名称
        AUDIO_PLAYER_STACK_SIZE,    // 栈大小
        NULL,                       // 任务参数
        5,                          // 优先级
        audio_player_stack,         // 栈数组(PSRAM)
        &audio_player_task_buffer   // 任务控制块(内部RAM)
    );
    
    if (s_task == NULL) {
        s_running = false;
        return ESP_ERR_NO_MEM;
    }
    return ESP_OK;
}

esp_err_t audio_player_stop(void)
{
    if (!s_running) return ESP_ERR_INVALID_STATE;
    s_running = false;
    return ESP_OK;
}

bool audio_player_running(void)
{
    return s_running;
}

esp_err_t audio_player_feed_pcm(const int16_t *pcm, size_t sample_count)
{
    if (!pcm || sample_count == 0) return ESP_ERR_INVALID_ARG;
    size_t bytes = sample_count * sizeof(int16_t);
    size_t w = rb_write(&s_rb, (const uint8_t *)pcm, bytes);
    return (w > 0) ? ESP_OK : ESP_ERR_NO_MEM;
}


