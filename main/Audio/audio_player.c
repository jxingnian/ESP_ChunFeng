/*
 * @Author: generated by assistant
 * @Description: 简易音频播放器实现
 */
#include "audio_player.h"
#include "audio_hal.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"
#include <string.h>
#include <stdlib.h>

typedef struct {
    uint8_t *buffer;
    size_t   size;
    volatile size_t write_pos;
    volatile size_t read_pos;
    SemaphoreHandle_t mutex;
    SemaphoreHandle_t data_sem;
} pcm_ring_t;

static const char *TAG = "AUDIO_PLAYER";
static pcm_ring_t s_rb = {0};
static TaskHandle_t s_task = NULL;
static size_t s_frame_samples = 1024;
static bool s_running = false;

static esp_err_t rb_init(pcm_ring_t *rb, size_t bytes)
{
    if (!rb || bytes == 0) return ESP_ERR_INVALID_ARG;
    rb->buffer = (uint8_t *)malloc(bytes);
    if (!rb->buffer) return ESP_ERR_NO_MEM;
    rb->size = bytes;
    rb->write_pos = rb->read_pos = 0;
    rb->mutex = xSemaphoreCreateMutex();
    rb->data_sem = xSemaphoreCreateBinary();
    if (!rb->mutex || !rb->data_sem) return ESP_ERR_NO_MEM;
    return ESP_OK;
}

static void rb_deinit(pcm_ring_t *rb)
{
    if (!rb) return;
    if (rb->mutex) vSemaphoreDelete(rb->mutex);
    if (rb->data_sem) vSemaphoreDelete(rb->data_sem);
    if (rb->buffer) free(rb->buffer);
    memset(rb, 0, sizeof(*rb));
}

static size_t rb_write(pcm_ring_t *rb, const uint8_t *data, size_t len)
{
    if (!rb || !data || len == 0) return 0;
    if (xSemaphoreTake(rb->mutex, pdMS_TO_TICKS(10)) != pdTRUE) return 0;
    size_t space = (rb->read_pos <= rb->write_pos)
                     ? (rb->size - rb->write_pos + rb->read_pos - 1)
                     : (rb->read_pos - rb->write_pos - 1);
    if (len > space) len = space;
    for (size_t i = 0; i < len; ++i) {
        rb->buffer[rb->write_pos] = data[i];
        rb->write_pos = (rb->write_pos + 1) % rb->size;
    }
    xSemaphoreGive(rb->mutex);
    if (len) xSemaphoreGive(rb->data_sem);
    return len;
}

static size_t rb_read(pcm_ring_t *rb, uint8_t *out, size_t max_len, uint32_t timeout_ms)
{
    if (!rb || !out || max_len == 0) return 0;
    if (rb->read_pos == rb->write_pos && timeout_ms) {
        if (xSemaphoreTake(rb->data_sem, pdMS_TO_TICKS(timeout_ms)) != pdTRUE) return 0;
    }
    if (xSemaphoreTake(rb->mutex, pdMS_TO_TICKS(10)) != pdTRUE) return 0;
    size_t avail = (rb->write_pos >= rb->read_pos)
                     ? (rb->write_pos - rb->read_pos)
                     : (rb->size - rb->read_pos + rb->write_pos);
    if (max_len > avail) max_len = avail;
    for (size_t i = 0; i < max_len; ++i) {
        out[i] = rb->buffer[rb->read_pos];
        rb->read_pos = (rb->read_pos + 1) % rb->size;
    }
    xSemaphoreGive(rb->mutex);
    return max_len;
}

static void player_task(void *arg)
{
    const size_t bytes_per_sample = sizeof(int16_t);
    const size_t frame_bytes = s_frame_samples * bytes_per_sample;
    int16_t *frame = (int16_t *)malloc(frame_bytes);
    if (!frame) {
        s_running = false;
        vTaskDelete(NULL);
        return;
    }
    while (s_running) {
        size_t got = rb_read(&s_rb, (uint8_t *)frame, frame_bytes, 200);
        if (got >= bytes_per_sample) {
            size_t samples = got / bytes_per_sample;
            audio_hal_write(frame, samples, 100);
        }
    }
    free(frame);
    vTaskDelete(NULL);
}

esp_err_t audio_player_init(size_t ring_bytes, size_t frame_samples)
{
    if (s_running) return ESP_ERR_INVALID_STATE;
    if (ring_bytes == 0) ring_bytes = 64 * 1024;
    if (frame_samples == 0) frame_samples = 1024;
    ESP_ERROR_CHECK(audio_hal_init());
    s_frame_samples = frame_samples;
    return rb_init(&s_rb, ring_bytes);
}

void audio_player_deinit(void)
{
    if (s_running) return;
    rb_deinit(&s_rb);
}

esp_err_t audio_player_start(void)
{
    if (s_running) return ESP_ERR_INVALID_STATE;
    s_running = true;
    if (xTaskCreatePinnedToCore(player_task, "audio_player", 3 * 1024, NULL, 5, &s_task, 0) != pdPASS) {
        s_running = false;
        return ESP_ERR_NO_MEM;
    }
    return ESP_OK;
}

esp_err_t audio_player_stop(void)
{
    if (!s_running) return ESP_ERR_INVALID_STATE;
    s_running = false;
    return ESP_OK;
}

bool audio_player_running(void)
{
    return s_running;
}

esp_err_t audio_player_feed_pcm(const int16_t *pcm, size_t sample_count)
{
    if (!pcm || sample_count == 0) return ESP_ERR_INVALID_ARG;
    size_t bytes = sample_count * sizeof(int16_t);
    size_t w = rb_write(&s_rb, (const uint8_t *)pcm, bytes);
    return (w > 0) ? ESP_OK : ESP_ERR_NO_MEM;
}


